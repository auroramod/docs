"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[600],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return f}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=s(t),f=i,m=d["".concat(c,".").concat(f)]||d[f]||p[f]||r;return t?a.createElement(m,l(l({ref:n},u),{},{components:t})):a.createElement(m,l({ref:n},u))}));function f(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=d;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8373:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return u},default:function(){return d}});var a=t(7462),i=t(3366),r=(t(7294),t(3905)),l=["components"],o={},c="GSC references in Lua",s={unversionedId:"lua-gsc-reference",id:"lua-gsc-reference",isDocsHomePage:!1,title:"GSC references in Lua",description:"Calling GSC functions",source:"@site/docs/lua-gsc-reference.md",sourceDirName:".",slug:"/lua-gsc-reference",permalink:"/lua-gsc-reference",editUrl:"https://github.com/h1-mod/docs/blob/main/docs/lua-gsc-reference.md",tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Lua Syntax",permalink:"/lua-scripting-syntax"},next:{title:"LUI Scripting",permalink:"/ui-scripting"}},u=[{value:"Calling GSC functions",id:"calling-gsc-functions",children:[{value:"&quot;Include&quot; functions",id:"include-functions",children:[],level:3},{value:"Functions in variables",id:"functions-in-variables",children:[],level:3}],level:2},{value:"Hooking (detouring) GSC functions",id:"hooking-detouring-gsc-functions",children:[],level:2},{value:"Incorrect/missing symbols on H1-Mod",id:"incorrectmissing-symbols-on-h1-mod",children:[],level:2}],p={toc:u};function d(e){var n=e.components,t=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"gsc-references-in-lua"},"GSC references in Lua"),(0,r.kt)("h2",{id:"calling-gsc-functions"},"Calling GSC functions"),(0,r.kt)("p",null,"Calling GSC functions from the Lua scripting is made easy thanks to fed. To do so, you need to use the H1 GSC dump and figure out what the file and function names. If the file/function you are looking for has a ",(0,r.kt)("inlineCode",{parentName:"p"},"_ID<decimal>")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"_id_<hex>")," prefix, this is most likely new code in H1 that isn't found in IW6 (Ghosts) or S1 (Advanced Warfare)."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"scriptcall")," function for Lua scripting is usually called on any sort of player entity or the level entity. To call on a player, doing ",(0,r.kt)("inlineCode",{parentName:"p"},"player:scriptcall(file, function, args)")," will work. However, if the function you are calling is from the level entity, you would use ",(0,r.kt)("inlineCode",{parentName:"p"},"game:scriptcall(file, function, args)")," from the game object."),(0,r.kt)("p",null,"In this example, we are going to be calling ",(0,r.kt)("inlineCode",{parentName:"p"},"maps/mp/_utility::_unsetPerk")," on last stand, martyrdom, and juggernaut perks. This code should be ran in a function that has access to a player variable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'function entity:player_spawned()\n    self:scriptcall("maps/mp/_utility", "_unsetperk", "specialty_pistoldeath")\n    self:scriptcall("maps/mp/_utility", "_unsetperk", "specialty_grenadepulldeath")\n    self:scriptcall("maps/mp/_utility", "_unsetperk", "specialty_armorvest")\nend\n\nlevel:onnotify("connected", function(player)\n    player:onnotify("spawned_player", function()\n        player:player_spawned()\n    end)\nend)\n')),(0,r.kt)("h3",{id:"include-functions"},'"Include" functions'),(0,r.kt)("p",null,'To "include" functions from files like in GSC, you can use the ',(0,r.kt)("inlineCode",{parentName:"p"},"game:include(file)")," function from the game object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'game:include("maps/mp/_utility")\n\nfunction entity:player_spawned()\n    -- Included function names are lowercase\n    self:_unsetperk("specialty_pistoldeath")\n    self:_unsetperk("specialty_grenadepulldeath")\n    self:_unsetperk("specialty_armorvest")\nend\n\nlevel:onnotify("connected", function(player)\n    player:onnotify("spawned_player", function()\n        player:player_spawned()\n    end)\nend)\n')),(0,r.kt)("p",null,"Or, you could use the ",(0,r.kt)("inlineCode",{parentName:"p"},"game:getfunctions(file)")," function from the game object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local utility = game:getfunctions("maps/mp/_utility")\n\nfunction entity:player_spawned()\n    utility._unsetperk(self, "specialty_pistoldeath")\n    utility._unsetperk(self, "specialty_grenadepulldeath")\n    utility._unsetperk(self, "specialty_armorvest")\nend\n\nlevel:onnotify("connected", function(player)\n    player:onnotify("spawned_player", function()\n        player:player_spawned()\n    end)\nend)\n')),(0,r.kt)("h3",{id:"functions-in-variables"},"Functions in variables"),(0,r.kt)("p",null,"Functions in variables, such as structs or arrays, will be automatically converted to a Lua function. The first argument must always be the entity to call the function on."),(0,r.kt)("h2",{id:"hooking-detouring-gsc-functions"},"Hooking (detouring) GSC functions"),(0,r.kt)("p",null,"Same as above, you need to know what a file may be named and what a function may be named."),(0,r.kt)("p",null,"Detouring a function redirects the function's call to the function callback you provide. The ",(0,r.kt)("inlineCode",{parentName:"p"},"game:detour")," function is always from the game object. The first parameter of the detour will ",(0,r.kt)("strong",{parentName:"p"},"always")," be the entity that called it. (as defined ",(0,r.kt)("inlineCode",{parentName:"p"},"self_")," in example)"),(0,r.kt)("p",null,"In this example, we will be hooking ",(0,r.kt)("inlineCode",{parentName:"p"},"codecallback_playerkilled")," and checking who the attacker is."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'-- we define a variable so we can use this in our callback function\nlocal playerkilled_hook = nil\n\n-- our callback function for the detour\nfunction playerkilled_stub(self_, einflictor, eattacker, idamage, smeansofdeath, sweapon, vdir, shitloc, timeoffset, deathanimduration)\n    if eattacker ~= nil or game:isplayer(eattacker) == 1 then\n        print("The attacker is " .. eattacker.name)\n    else\n        print("The attacker is invalid or isn\'t a player")\n    end\n\n    -- [...]\n\n    -- the invoke function will call the original function from the game\'s stock GSC. we can modify parameters here too!\n    playerkilled_hook.invoke(self_, einflictor, eattacker, idamage, smeansofdeath, sweapon, vdir, shitloc, timeoffset, deathanimduration)\nend\n\nplayerkilled_hook = game:detour("maps/mp/gametypes/_callbacksetup", "codecallback_playerkilled", playerkilled_stub)\n')),(0,r.kt)("p",null,"To disable or enable a detour, the ",(0,r.kt)("inlineCode",{parentName:"p"},".disable")," and ",(0,r.kt)("inlineCode",{parentName:"p"},".enable")," methods exist."),(0,r.kt)("h2",{id:"incorrectmissing-symbols-on-h1-mod"},"Incorrect/missing symbols on H1-Mod"),(0,r.kt)("p",null,"This GSC dump may contain symbols that H1-Mod may or may not have named or is not correctly named. Navigating to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/h1-mod/h1-mod/blob/develop/src/client/game/scripting/function_tables.cpp"},"the function table")," and finding the function_map, method_map, & token_map maps will help you. ",(0,r.kt)("inlineCode",{parentName:"p"},"CTRL + F")," (Find) and search your desired value (ex: ",(0,r.kt)("inlineCode",{parentName:"p"},"isplayer"),") and see if it exists."),(0,r.kt)("p",null,"If the symbol you are trying to call isn't named, then you have to the ",(0,r.kt)("inlineCode",{parentName:"p"},"_func_<hex>")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"_meth_<hex>")," prefix. For example, if ",(0,r.kt)("inlineCode",{parentName:"p"},"isplayer")," wasn't properly named, then you would refer to the hexdecimal value (",(0,r.kt)("inlineCode",{parentName:"p"},"0x1AD"),"). You would call this function as ",(0,r.kt)("inlineCode",{parentName:"p"},"game:_func_1AD(player)"),"."))}d.isMDXComponent=!0}}]);